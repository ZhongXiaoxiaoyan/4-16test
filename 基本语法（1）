5-7-
学习总结
1. 结构体和共同体的区别。
定义：
  结构体struct：把不同类型的数据组合成一个整体，自定义类型。
  共同体union：使几个不同类型的变量共同占用一段内存。
地址：
  struct和union都有内存对齐，结构体的内存布局依赖于CPU、操作系统、编译器及编译时的对齐选项。
关于内存对齐，先让我们看四个重要的基本概念：
  1.数据类型自身的对齐值：
  对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。
  2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。
  3.指定对齐值：#pragma pack(n)，n=1,2,4,8,16改变系统的对齐系数
  4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。
常见数据类型及其长度：
  注意long int和int一样是4byte，long double和double一样是8byte。（关于long double，ANSI C标准规定了double变量存储为 IEEE 64 位（8 个字节）浮点数值，但并未规定long double的确切精度。所以对于不同平台可能有不同的实现。有的是8字节，有的是10字节，有的是12字节或16字节。）
  在标准c++中，int的定义长度要依靠你的机器的字长，也就是说，如果你的机器是32位的，int的长度为32位，如果你的机器是64位的，那么int的标准长度就是64位。经测试，在64位操作系统下，int的长度还是32位的。

结构体struct：不同之处，stuct里每个成员都有自己独立的地址。sizeof(struct)是内存对齐后所有成员长度的加和。
共同体union：当共同体中存入新的数据后，原有的成员就失去了作用，新的数据被写到union的地址中。sizeof(union)是最长的数据成员的长度。
总结： struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。

2.static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗？

static的作用：
对变量：
  1.局部变量：
  在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。
    1）内存中的位置：静态存储区
    2）初始化：局部的静态变量只能被初始化一次，且C中不可以用变量对其初始化，而C++可以用变量对其初始化。（详见：http://www.cnblogs.com/novice-dxx/p/7094690.html）
    3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
   注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。
  
  2.全局变量
  在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
  1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
  2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
  3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。
  注：static修饰全局变量，并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，好处如下：（1）不会被其他文件所访问，修改（2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。而普通全局变量只要定义了，任何地方都能使用，使用前需要声明所有的.c文件，只能定义一次普通全局变量，但是可以声明多次（外部链接）。注意：全局变量的作用域是全局范围，但是在某个文件中使用时，必须先声明。
  

对类中的：
1.成员变量
　　用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化(初始化格式： int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化 。
特点： 
    不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。 
    静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。
    静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的指针或引用。
2.成员函数
    用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。
    静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。base::func(5,3);当static成员函数在类外定义时不需要加static修饰符。
    在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。 
    不可以同时用const和static修饰成员函数。
    C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。
    我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。

const的作用：
  1.限定变量为不可修改。
  2.限定成员函数不可以修改任何数据成员。
  3.const与指针：
  const char *p 表示 指向的内容不能改变。
  char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。
