3.指针和引用的区别，引用可以用常指针实现吗。
  本质上的区别是，指针是一个新的变量，只是这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量。
  而引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。
  (1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：
      int a=1;int *p=&a;
      int a=1;int &b=a;
      上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。
      而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。
  (2)可以有const指针，但是没有const引用（const引用可读不可改，与绑定对象是否为const无关）
  (3)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
  (4)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
  (5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
  (6)"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
  (7)指针和引用的自增(++)运算意义不一样；
指针传参的时候，还是值传递，试图修改传进来的指针的值是不可以的。只能修改地址所保存变量的值。
引用传参的时候，传进来的就是变量本身，因此可以被修改。

4.什么是多态，多态有什么用途。

  1.定义：“一个接口，多种方法”，程序在运行时才决定调用的函数。
  2.实现：C++多态性主要是通过虚函数实现的，虚函数允许子类重写override(注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表/类型不同）。
    多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。
    如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。
    而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。
  3.目的：接口重用。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。
  4.用法：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。
    补充一下关于重载、重写、隐藏（总是不记得）的区别：
        Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。
        （1）相同的范围（在同一个类中）；
        （2）函数名字相同；
        （3）参数不同；
        （4）virtual 关键字可有可无。
        Override(重写)：是指派生类函数覆盖基类函数，特征是：
        （1）不同的范围（分别位于派生类与基类）；
        （2）函数名字相同；
        （3）参数相同；
        （4）基类函数必须有virtual 关键字。
        注：重写基类虚函数的时候，会自动转换这个函数为virtual函数，不管有没有加virtual，因此重写的时候不加virtual也是可以的，不过为了易读性，还是加上比较好。
        Overwrite(隐藏)：隐藏，是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
        （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
        （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。
    补充一下虚函数表：
    多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。
    如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表，虚函数表存储的每一项是一个虚函数的地址。
    这个类的每一个对象都会包含一个虚指针（虚指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），这个虚指针指向虚函数表。
    注：对象不包含虚函数表，只有虚指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表。
5.各个排序算法的时间复杂度和稳定性，快排的原理。
    插入排序
　　    每次将一个待排序的数据，跟前面已经有序的序列的数字一一比较找到自己合适的位置，插入到序列中，直到全部数据插入完成。
    
    希尔排序
　　    先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插”
    
    冒泡排序
        通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了。重复N次即可以使数组有序。
        冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有无数据交换就可以判断是否要继续循环。
        冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。
    
    快速排序
        “挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。
        然后j--由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。
        重复进行这种“挖坑填数”直到i==j。
        再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。
        因此将数组分成二部分再分别重复上述步骤就完成了排序。
        
    选择排序
        数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。
    
    堆排序
        堆的插入就是——每次插入都是将新数据放在数组最后，
        而从这个新数据的父结点到根结点必定是一个有序的数列，
        因此只要将这个新数据插入到这个有序数列中即可。
        
        堆的删除就是——堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。
        调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，
        反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。
        
        因此，堆的插入和删除非常类似直接插入排序，只不是在二叉树上进行插入过程。所以可以将堆排序形容为“树上插”
    
    归并排序
        归并排序主要分为两步：分数列（divide），每次把数列一分为二，然后分到只有两个元素的小数列；
        合数列（Merge），合并两个已经内部有序的子序列，直至所有数字有序。用递归可以实现。
    
    基数排序（桶排序）
        基数排序，第一步根据数字的个位分配到每个桶里，在桶内部排序，然后将数字再输出（串起来）；
        然后根据十位分桶，继续排序，再串起来。直至所有位被比较完，所有数字已经有序。




